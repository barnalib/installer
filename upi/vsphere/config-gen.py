#!/usr/bin/env python

# Este script toma como parametro un path a un archivo de configuracion terraform.tfvars
# Como resultado imprime la configuracion del server DHCP y los comandos de GOVC para controlar el VMware

import os
import re
import subprocess
import sys
import stat
import datetime

# Validar prerequisitos: terraform, govc, dig, dhcpd
for cmd in ["terraform", "govc", "dig", "dhcpd"]:
    if os.system("which " + cmd) != 0:
        print(" * ERROR * el comando: " + cmd + " no se encuentra instalado")


# Primer paso es importar el archivo
filename = sys.argv[1]

terraform_file = open(filename, "r")

# Proceso el archivo leyendo las variables del mismo, por suerte el formato de variables de terraform es igual al de python
for line in terraform_file:
    #print(line)
    
    comment = re.search("^//", line)
    control_plane_ignition = re.search("END_OF_MASTER_IGNITION", line)
    compute_ignition = re.search("END_OF_WORKER_IGNITION", line)

    if (comment or control_plane_ignition or compute_ignition):
      continue

    exec(line)
    
#print (compute_names)

# Generar los comandos para apagar las VMs
print("\n# 2) Apagar las VMs")
for node in bootstrap_name+control_plane_names+compute_names:
    continue
    #print("govc vm.power -off /%s/vm/%s/%s" % (vsphere_datacenter, cluster_id, node))

#print("\n# 3) Setear MAC addressess")
node_mac = {}
for node in bootstrap_name+control_plane_names+compute_names:
    #govc_proc = subprocess.Popen("govc device.info -vm='/%s/vm/%s/%s' ethernet-0" % (vsphere_datacenter, cluster_id, node), stdout=subprocess.PIPE, shell=True)
    
    node_mac[node] = "00:00:00:00:00:00"
    
    continue
    
    for line in iter(govc_proc.stdout.readline, ""):
        #print line
        mac_re = re.search("MAC Address", line)
        
        if (mac_re):
            mac_address = line.split(": ")[1].strip()
            node_mac[node] = mac_address
            #print ("govc vm.network.change -vm /%s/vm/%s/%s -net '%s' -net.address %s ethernet-0" % (vsphere_datacenter, cluster_id, node, vm_network, mac_address))
    

# Generar la configuracion del server DHCP
# Grabar un archivo dhpcd.conf y mostrar el comando para copiarlo a /etc + start/stop/enable del dhpcd + yum install (suponer que arrancamos de 0) + echo "" > /var/lib/dhpcd/lease
print("\n# 4) Configurar y levantar el DHCP server")

# Hacer backup del archivo dhcpd.conf
#os.system("cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf-" + datetime.datetime.now().strftime("%Y%m%d"))

# Crear un archivo de configuracion /etc/dhcp/dhcpd.conf con las MAC Address

#dhcpd_file = os.open("dhcpd.conf", os.O_RDWR | os.O_CREAT)

#ret = os.write(dhcpd_file, \

# Obtengo la subred y la mascara
def cidr_to_netmask(cidr):
  cidr = int(cidr)
  mask = (0xffffffff >> (32 - cidr)) << (32 - cidr)
  return (str( (0xff000000 & mask) >> 24)   + '.' +
          str( (0x00ff0000 & mask) >> 16)   + '.' +
          str( (0x0000ff00 & mask) >> 8)    + '.' +
          str( (0x000000ff & mask)))

subnet = machine_cidr.split("/")[0]
cidr = machine_cidr.split("/")[1]

netmask = cidr_to_netmask(cidr)

dhcpd_conf = \
'''
# dhcpd.conf
# Generated by: config-gen.py

option domain-name "%s";
option domain-name-servers %s, %s, %s;

default-lease-time 600;
max-lease-time 7200;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

subnet %s netmask %s {
    option routers %s;
}
''' % (cluster_domain, dns_ips[0], dns_ips[1], dns_ips[2], subnet, netmask, gateway_ip)

for node in bootstrap_name+control_plane_names+compute_names:
    test = \
    '''
    host %s {
      hardware ethernet %s;
      option host-name "%s";
      fixed-address %s;
    }
    ''' % (node, node_mac[node], node + "." + cluster_domain, "192.168.140.3")
    #print(node + " -> " + node_mac[node])
    #print (test)
    
print(dhcpd_conf)

# Writing text
#ret = os.write(dhcpd_file, "This is test")

# Close opened file
#os.close(dhcpd_file)

#os.chmod("dhcpd.conf", stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)


# Detener el dhcpd
#"systemctl stop dhcpd"

# Borrar los leases
#"echo '' > /var/lib/dhcpd/dhcpd.leases"
#"echo '' > /var/lib/dhcpd/dhcpd.leases~"

# Iniciar el dhcpd
#"systemctl start dhcpd"

# Mostrar el status
#"systemctl status dhcpd"


# Generar los comandos para encender las VMs
print("\n# 5) levantar las VMs")
for node in bootstrap_name+control_plane_names+compute_names:
    continue
    #print("govc vm.power -on /%s/vm/%s/%s" % (vsphere_datacenter, cluster_id, node))

# Generar los comandos para planchar las MAC Address



